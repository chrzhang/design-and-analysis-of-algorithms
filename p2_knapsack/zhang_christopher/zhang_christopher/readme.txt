BestFirstSearch
Code by Christopher Zhang

Solve the 0-1 knapsack problem using a best-first search variation of the branch
and bound algorithm. The optimal solution should be found in the fastest time
possible.

The program is ran as ./BestFirstSearch fileIn.txt fileOut.txt

Input is read from fileIn.txt.
    The first line contains the number of items to be considered. Following
    lines contain data of the form " weight, profit " for each item that is
    to be considered.

Output is written into fileOut.txt.
    The first line contains the number of items, the maximum profit, and the
    size of the optimal solution.
    The second line should have the total number of nodes in the final tree and
    the total number of leaf nodes.
    The remaining lines should contain the sorted (by price per weight) items in
    the optimal packing.

How to compile:

    make
    
How to run:

    BestFirstSearch <fileIn.txt> <fileOut.txt>
    
    Use ./BestFirstSearch if not in ROOT

Data structures and implementations:
    Each item is read into one standard library vector that stores them as  
    structs composed of weight and profit. 
    
    The vector is then sorted according to profit per weight. 
    
    Note: The values are stored as doubles because there was no guarantee on 
    type of input and there is no reason why the program should not work for 
    weights or profits that are not expressed as whole numbers. The main reason
    for the use of doubles was to be able to cross-check results with those
    generated from:
    
    "0-1 Knapsack Problem" from the Wolfram Demonstrations Project
     http://demonstrations.wolfram.com/01KnapsackProblem/
     Contributed by: Conrad A. Benulis
    
    With this sorted vector, each index will represent a level in the pruned 
    state space tree for the decision tree.

    The decision tree is a binary tree where each node is a struct containing
    a profit-thus-far, weight-thus-far, and bound. The bound is computed as
    the sum of the profit-thus-far and the solution of the fractional-knapsack
    problem for all levels greater than the current level. (Note: level 0
    represents the root, and level 1 represents the first item and so forth) 

    Levels are easily accessible by indexing the vector of sorted items. As the
    tree is constructed, the maximum profit can be found at a node. By having
    each node store whether it is a yes-child (left) or a no-child (right) and
    a pointer to its parent node, backtracing upward the tree from the optimal
    node is possible. Recursively calling such a function on the optimal node
    will have it "deepen" upwards and print the path in reverse. At each node
    along the path, check to see if the node is a yes-child or not. If it is,
    it is part of the optimal packing. This is the sole reason why an explicit
    binary tree is constructed.

    File input and output involves use of stringstream.

Analysis/discussion of computation time:
    In general cases, the best-first search approach generates most or all of
    the nodes that a breadth-first search approach would. The savings vary on
    the nature of the data and in the worst-case, all stages and leaves are
    generated. The tree will be a complete binary tree, having 2^(n-1)-1 nodes.
    When expressed in O-notation, this is exponential or O(2^n). However, the
    best-first-search outperforms breadth- or depth- based approaches provided
    the use of the priority queue is not a significant hindrance.

    In the file in/a.txt (the same input given in the assignment example), the
    savings of using best-first search is 6 fewer nodes than breadth-first.

Classes used and their interaction:
    Class: Knapsack
    Purpose: Encapsulates the binary state space pruned tree generated by the
             best-first, branch and bound approach for the problem. It also
             stores the vector of items sorted by price per weight for the
             item collection. A few class variables initialized to zero will be
             set once the tree is generated that will then be written to a file.
    
        Function: Knapsack()
        Purpose: Default constructor that initializes fields to empty values.
        Assumptions: There are no parameters.

        Function: ~Knapsack()
        Purpose: Destructor to de-allocate the nodes in the binary tree.
        Assumptions: There are no parameters.

        Function: void destroyFrom(Node * n)
        Purpose: Helper function for the destroyer (recursively kills children).
        Assumptions: n can be either nullptr or not, either case is handled.

        Function: readFromFile(std::string filename)
        Purpose: Open the file to read in and initialize data members.
        Assumptions: Hopefully the file exists with the right format, otherwise
                     display an error.

        Function: writeToFile(std::string filename)
        Purpose: Open the file to write to in the correct format.
        Assumptions: The file to be written to has a valid filename.

        Function: int considerItem(double weight, double profit)
        Purpose: Check to see if two values can compose a possible item.
        Assumptions: This is a validity checking function.

        Function: int addItemToSet(double weight, double profit)
        Purpose: Add a vlaidated item to the vector of possibilities.
        Assumptions: Input passed the test in considerItem().

        Function: void sortGoodies()
        Purpose: Sort the vector of item possibilities by profit per weight.
        Assumptions: There are no parameters.

        Function: double KWF(int startLevel, double capacityLeft)
        Purpose: Calculate fractional knapsack given a capacity and level.
        Assumptions: startLevel should be a valid index and the capacity left
                     ought to be positive or zero.

        Function: void grow()
        Purpose: Build the tree according to the best-first, branch and bound
                 algorithm.
        Assumptions: There are no parameters.

        Function: void getBestGoodies(std::stringstream & ss)
        Purpose: Backtrack from the optimal node, writing the optimal packing
                 to the stringstream in reverse order, which is sorted.
        Assumptions: The stream is valid and there is an optimal node found.

        Function: void getEm(std::stringstream & ss, Node * d)
        Purpose: The actual recursive backtracking function that is called in
                 getBestGoodies(). It continually calls parent, going up the
                 tree, then writes each yes-child along the path back down to
                 the stream.
        Assumptions: The stream is valid and there is a node with a nullptr
                    as its parent, namely the root.

        Function: friend std::ostream & operator<<(std::ostream & stream, 
                  const Knapsack & k)
        Purpose: Debug the vector of item possibilities by printing them out.
        Assumptions: Stream is valid, and knapsack instance created.

        Function: void visualize() const
        Purpose: Print a horizontal representation for the tree for debugging;
                 helpful for small trees.
        Assumptions: Both cases for root being a nullptr or not are handled.

        Function: void visualize_helper(int indent, Node * t) const
        Purpose: Helper function used in visualizing the tree horizontally
        Assumptions: indent is positive and the tree is small enough to be worth
                     printing accurately.

    File: Driver (instantiates a Knapsack object to process)
    Purpose: Handles the arguments, main, file input and output result
